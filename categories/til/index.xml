<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>til on Lllama's blog</title><link>https://lllama.github.io/categories/til/</link><description>Recent content in til on Lllama's blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 17 Apr 2023 08:43:21 +0100</lastBuildDate><atom:link href="https://lllama.github.io/categories/til/index.xml" rel="self" type="application/rss+xml"/><item><title>Helix for vim users</title><link>https://lllama.github.io/posts/helix-for-vim-users/</link><pubDate>Mon, 17 Apr 2023 08:43:21 +0100</pubDate><guid>https://lllama.github.io/posts/helix-for-vim-users/</guid><description>Periodically, I have a go at using an editor other than vim. This normally results in me realising that I just needed a change of vim colour scheme but I’ve just discovered Helix which might be just enough like vim for me to stick around.
My reason for giving it a go is that I want something with easy to use language server support. Neovim would probably be a sensible choice but helix seems to be nicely configured out of the box, so I’m going to try that first.</description></item><item><title>Textual in WSL</title><link>https://lllama.github.io/posts/textual-in-wsl/</link><pubDate>Fri, 27 Jan 2023 11:52:07 +0000</pubDate><guid>https://lllama.github.io/posts/textual-in-wsl/</guid><description>If you’re running textual apps under WSL there are two things needed to make sure they look pretty:
make sure you’re using a good coding font with all the various Unicode characters make sure COLORTERM is set to truecolor in your environment.</description></item><item><title>Sanic Custom Route Parameters</title><link>https://lllama.github.io/posts/sanic-custom-parameters/</link><pubDate>Mon, 23 Jan 2023 12:11:33 +0000</pubDate><guid>https://lllama.github.io/posts/sanic-custom-parameters/</guid><description>Sanic supports path parameters like the majority of web frameworks. It supports a number of built-in types but you can define your own.
Something like this from Adam on Discord:
import re from typing import NamedTuple DIMENSIONS_PATTERN = re.compile(r&amp;#34;(?P&amp;lt;width&amp;gt;\d+)x(?P&amp;lt;height&amp;gt;\d+)&amp;#34;) class Dimensions(NamedTuple): width: int height: int def _extract_dimensions(value: str) -&amp;gt; Dimensions: if match := DIMENSIONS_PATTERN.match(value): return Dimensions(**{k: int(v) for k, v in match.groupdict().items()}) raise ValueError(&amp;#34;Not proper dimensions format&amp;#34;) app.router.register_pattern( &amp;#34;dimensions&amp;#34;, _extract_dimensions, DIMENSIONS_PATTERN ) @app.</description></item></channel></rss>