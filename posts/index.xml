<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Lllama's blog</title><link>https://lllama.github.io/posts/</link><description>Recent content in Posts on Lllama's blog</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Tue, 27 Feb 2024 10:00:33 +0000</lastBuildDate><atom:link href="https://lllama.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>A BubbleTea App to View CloudWatch Logs</title><link>https://lllama.github.io/posts/bubbleteacwlogs/</link><pubDate>Tue, 27 Feb 2024 10:00:33 +0000</pubDate><guid>https://lllama.github.io/posts/bubbleteacwlogs/</guid><description>My favourite way to view CloudWatch logs is with the awslogs tool. Unfortunately, when I last installed it with pipx it gave me errors about missing packages1, so I decided to do what any sane person would do and write a new version in a completely different programming language.
I&amp;rsquo;m a big fan of python&amp;rsquo;s Textual library and TUIs in general, and I want 2024 to be my year of learning Go, so I&amp;rsquo;ve decided to look at using that along with BubbleTea.</description></item><item><title>Exploring Burp Project Files</title><link>https://lllama.github.io/posts/exploring-burp-project-files/</link><pubDate>Thu, 28 Sep 2023 20:52:54 +0100</pubDate><guid>https://lllama.github.io/posts/exploring-burp-project-files/</guid><description>It’s been a while since I’ve done any web app testing. A long while. Last time I used Burp, there was no such thing as project files. There was a state file, which was some strange psuedo-xml file format but the new project files look like they contain more information. A lot more information. So I’ve decided to have a prod and see whether I can extract any useful information from them.</description></item><item><title>sanic-kit</title><link>https://lllama.github.io/posts/sanic-kit/</link><pubDate>Mon, 17 Apr 2023 20:35:00 +0100</pubDate><guid>https://lllama.github.io/posts/sanic-kit/</guid><description>HTMx has been a revelation for writing web apps. I’d previously used my preferred DERP stack (Django, Ember, REST framework, postgresql) which produced nice enough apps but took a lot of effort and had lots of redundant code: Postgres tables needed to be Django models, which needed to be DRF serialisers, which needed Ember Data models, and then finally rendered to the DOM.
Writing with htmx meant I could have most of the shiny but I only need to produce the html on the server.</description></item><item><title>Helix for vim users</title><link>https://lllama.github.io/posts/helix-for-vim-users/</link><pubDate>Mon, 17 Apr 2023 08:43:21 +0100</pubDate><guid>https://lllama.github.io/posts/helix-for-vim-users/</guid><description>Periodically, I have a go at using an editor other than vim. This normally results in me realising that I just needed a change of vim colour scheme but I’ve just discovered Helix which might be just enough like vim for me to stick around.
My reason for giving it a go is that I want something with easy to use language server support. Neovim would probably be a sensible choice but helix seems to be nicely configured out of the box, so I’m going to try that first.</description></item><item><title>Textual in WSL</title><link>https://lllama.github.io/posts/textual-in-wsl/</link><pubDate>Fri, 27 Jan 2023 11:52:07 +0000</pubDate><guid>https://lllama.github.io/posts/textual-in-wsl/</guid><description>If you’re running textual apps under WSL there are two things needed to make sure they look pretty:
make sure you’re using a good coding font with all the various Unicode characters make sure COLORTERM is set to truecolor in your environment.</description></item><item><title>Textual Screen Transitions</title><link>https://lllama.github.io/posts/textual-screen-transitions/</link><pubDate>Thu, 26 Jan 2023 11:49:38 +0000</pubDate><guid>https://lllama.github.io/posts/textual-screen-transitions/</guid><description>Textual brings a little bit of the web to the terminal. Apps have a DOM that is composed of widgets, and layout and styling is all handled with CSS.
Apps can also be made up of multiple Screens, which could be thought of as separate URLs or pages within a web-app. With this in mind, I started wondering about whether it would be possible to animate a transition between two different screens.</description></item><item><title>URLs are harder than they should be</title><link>https://lllama.github.io/posts/urls-suck/</link><pubDate>Tue, 24 Jan 2023 16:13:28 +0000</pubDate><guid>https://lllama.github.io/posts/urls-suck/</guid><description>My current toy web-app is a webmail client. It provides the standard inbox view and then let’s you drill down to view actual mails. I also then have actions you can perform on these.
The URLs for these are fairly basic:
/mailbox/&amp;lt;ID&amp;gt; /mailbox/&amp;lt;ID&amp;gt;/&amp;lt;mail ID&amp;gt; /mailbox/&amp;lt;ID&amp;gt;/&amp;lt;mail ID&amp;gt;/delete So far, so whatever. The pain comes with how to construct the drill down urls from the current page. I can get the current URL in my templates with request.</description></item><item><title>Validating Input in Textual</title><link>https://lllama.github.io/posts/textual-input-validation/</link><pubDate>Tue, 24 Jan 2023 15:05:09 +0000</pubDate><guid>https://lllama.github.io/posts/textual-input-validation/</guid><description>Textual has a number of built in widgets to help capture user input. For text input, there is the standard Input widget. By default, this will let the user enter any characters that they wish.
Whenever a new value is entered, textual will fire off an Input.Changed event, that you can handle with an on_input_changed method in your App (or wherever). You may then be tempted to use this handler to validate the user input - the Input has a reactive variable but there’s no easy way to wire something up to an instance’s methods.</description></item><item><title>Sanic Custom Route Parameters</title><link>https://lllama.github.io/posts/sanic-custom-parameters/</link><pubDate>Mon, 23 Jan 2023 12:11:33 +0000</pubDate><guid>https://lllama.github.io/posts/sanic-custom-parameters/</guid><description>Sanic supports path parameters like the majority of web frameworks. It supports a number of built-in types but you can define your own.
Something like this from Adam on Discord:
import re from typing import NamedTuple DIMENSIONS_PATTERN = re.compile(r&amp;#34;(?P&amp;lt;width&amp;gt;\d+)x(?P&amp;lt;height&amp;gt;\d+)&amp;#34;) class Dimensions(NamedTuple): width: int height: int def _extract_dimensions(value: str) -&amp;gt; Dimensions: if match := DIMENSIONS_PATTERN.match(value): return Dimensions(**{k: int(v) for k, v in match.groupdict().items()}) raise ValueError(&amp;#34;Not proper dimensions format&amp;#34;) app.router.register_pattern( &amp;#34;dimensions&amp;#34;, _extract_dimensions, DIMENSIONS_PATTERN ) @app.</description></item><item><title>Deploy Python With Deb</title><link>https://lllama.github.io/posts/deploy-python-with-deb/</link><pubDate>Tue, 19 Jul 2022 12:28:33 +0100</pubDate><guid>https://lllama.github.io/posts/deploy-python-with-deb/</guid><description>One of the worst parts about working with python is how to share your code, or deploy it on another machine. If you&amp;rsquo;re following preferred practices, then you&amp;rsquo;re probably developing using a virtual environment. But that means you need a way to have the same environment where your app is going to run. Either your users need to go through several steps to create a virtual environment and then install your app and its dependencies to it, or you need to ship the environment along with your app.</description></item></channel></rss>